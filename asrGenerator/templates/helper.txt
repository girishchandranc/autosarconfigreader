{%- macro createContainerClass(container) -%}
# Container configuration node for {{ container.get_name() }}
class {{ container.get_class_name() }}(AutosarNode):
    def __init__(self, parent, node):
        """
        Constructor for {{ container.get_name() }} node.

        @param parent: The parent node under which the autosar node needs to be created.
        @param node: The xml node for which the autosar node needs to be created.
        """
        super().__init__(parent, node, '{{ container.get_name() }}', '{{ container.get_path() }}')
        self.__isChoiceContainer = {{ container.is_choice_container() }}

        {%- if container.get_sub_containers()|length > 0 %}
        #containers
            {%- for subContainer in container.get_sub_containers() %}
                {%- if subContainer.is_multi_instance_container() %}
        self.__{{ subContainer.get_name() }}s = []
                {%- else %}
        self.__{{ subContainer.get_name() }} = None
                {%- endif %}
            {%- endfor %}

        for subContainer in node.findall('{*}SUB-CONTAINERS/{*}ECUC-CONTAINER-VALUE'):
            definitionRef = subContainer.find('{*}DEFINITION-REF').text
            if definitionRef is not None:
                definitionName = definitionRef.split('/').pop()
            {%- for subContainer in container.get_sub_containers() %}
                {%- if loop.first %}
                if definitionName == '{{ subContainer.get_name() }}':
                {%- else %}
                elif definitionName == '{{ subContainer.get_name() }}':
                {%- endif %}
                {%- if subContainer.is_multi_instance_container() %}
                    self.__{{ subContainer.get_name() }}s.append({{ subContainer.get_class_name() }}(self, subContainer))
                {%- else %}
                    self.__{{ subContainer.get_name() }} = {{ subContainer.get_class_name() }}(self, subContainer)
                {%- endif %}  
            {%- endfor %}
        {%- endif %}

        {%- if container.get_parameters()|length > 0 %}
        #parameters
            {%- for parameter in container.get_parameters() %}
        self.__{{ parameter.get_name() }}_value = None
            {%- endfor %}

        for parameter in node.findall('{*}PARAMETER-VALUES/*'):
            definitionRef = parameter.find('{*}DEFINITION-REF').text
            if definitionRef is not None:
                definitionName = definitionRef.split('/').pop()
            {%- for parameter in container.get_parameters() %}
            {%- if loop.first %}
                if definitionName == '{{ parameter.get_name() }}':
            {%- else %}
                elif definitionName == '{{ parameter.get_name() }}':
            {%- endif %}
                    self.__{{ parameter.get_name() }}_value = self.{{ parameter.get_class_name() }}(self, parameter)
            {%- endfor %}
        {%- endif %}

        {%- if container.get_references()|length > 0 %}
        #references
            {%- for reference in container.get_references() %}
                {%- if reference.is_multi_instance_reference() %}
        self.__{{ reference.get_name() }}_values = []
                {%- else %}
        self.__{{ reference.get_name() }}_value = None
                {%- endif %}
            {%- endfor %}

        for reference in node.findall('{*}REFERENCE-VALUES/*'):
            definitionRef = reference.find('{*}DEFINITION-REF').text
            if definitionRef is not None:
                definitionName = definitionRef.split('/').pop()
            {%- for reference in container.get_references() %}
            {%- if loop.first %}
                if definitionName == '{{ reference.get_name() }}':
            {%- else %}
                elif definitionName == '{{ reference.get_name() }}':
            {%- endif %}
            {%- if reference.is_multi_instance_reference() %}
                    self.__{{ reference.get_name() }}_values.append(self.{{ reference.get_class_name() }}(self, reference))
            {%- else %}
                    self.__{{ reference.get_name() }}_value = self.{{ reference.get_class_name() }}(self, reference)
            {%- endif %}
            {%- endfor %}
        {%- endif %}

    def is_choice_container(self):
        return self.__isChoiceContainer

{% for subContainer in container.get_sub_containers() %}
    #Returns the configuration container {{ subContainer.get_name() }}
    {%- if subContainer.is_multi_instance_container() %}
    def get_{{ subContainer.get_name() }}s(self):
        return self.__{{ subContainer.get_name() }}s
    {%- else %}
    def get_{{ subContainer.get_name() }}(self):
        return self.__{{ subContainer.get_name() }}
    {%- endif %}  
{% endfor -%}

{%- for parameter in container.get_parameters() %}
    #Returns the parameter {{ parameter.get_name() }}
    def get_{{ parameter.get_name() }}(self):
        return self.__{{ parameter.get_name() }}_value
{% endfor -%}

{%- for reference in container.get_references() %}
    #Returns the reference {{ reference.get_name() }}
    {%- if reference.is_multi_instance_reference() %}
    def get_{{ reference.get_name() }}s(self):
        return self.__{{ reference.get_name() }}_values
    {%- else %}
    def get_{{ reference.get_name() }}(self):
        return self.__{{ reference.get_name() }}_value
    {%- endif %}
{% endfor -%}
{%- endmacro %}

{%- macro createParameterClass(parameter, ParameterTypes) %}
    # Parameter configuration node for {{ parameter.get_name() }}
    class {{ parameter.get_class_name() }}(AutosarNode):
        def __init__(self, parent, node):
            """
            Constructor for {{ parameter.get_name() }} node.

            @param parent: The parent node under which the autosar node needs to be created.
            @param node: The xml node for which the autosar node needs to be created.
            """
            super().__init__(parent, node, '{{ parameter.get_name() }}', '{{ parameter.get_path() }}')
            self.__value = None
            self.__valueNode = node.find('{*}VALUE')
            paramValue = self.__valueNode.text if self.__valueNode is not None else None
{%- if parameter.get_type() == ParameterTypes.INTEGER %}
            if paramValue is not None:
                self.__value = int(paramValue)
{% elif parameter.get_type() == ParameterTypes.FLOAT %}
            if paramValue is not None:
                self.__value = float(paramValue)
{% elif parameter.get_type() == ParameterTypes.BOOLEAN %}
            if paramValue is not None and paramValue == '1':
                self.__value = True
            else:
                self.__value = False
{% else %}
            self.__value = paramValue
{%- endif %}
            self.__type = {{ parameter.get_type() }}
            self.__isDefaultValueSet = {{ parameter.is_default_value_set() }}
            self.__defaultValue = {{ parameter.get_default_value() }}
{%- if parameter.get_type() == ParameterTypes.INTEGER or parameter.get_type() == ParameterTypes.FLOAT %}
            self.__isMinValueSet = {{ parameter.is_min_value_set() }}
            self.__min = {{ parameter.get_min_value() }}
            self.__isMaxValueSet = {{ parameter.is_max_value_set() }}
            self.__max = {{ parameter.get_max_value() }}
{% elif parameter.get_type() == ParameterTypes.ENUMERATION %}
            self.__enumLiterals = {{ parameter.get_enum_literals() }}
{%- endif %}

        #Get the parameter value
        def get_value(self):
            return self.__value
        
        #set the parameter value
        def set_value(self, value):
        {%- if parameter.get_type() == ParameterTypes.BOOLEAN %}
            self.__value = value
            self.__valueNode.text = '1' if value else '0'
            self._set_model_modified(True)
        {%- elif parameter.get_type() == ParameterTypes.ENUMERATION %}
            if value in self.__enumLiterals:
                self.__value = value
                self.__valueNode.text = value
                self._set_model_modified(True)
            else:
                raise ValueNotPossibleError(message = 'Cannot set the value {}. Only the values {} are possible'.format(value, str(self.__enumLiterals)))
        {%- elif parameter.get_type() == ParameterTypes.INTEGER or parameter.get_type() == ParameterTypes.FLOAT %}
            if value >= self.__min and value <= self.__max:
                self.__value = value
                self.__valueNode.text = str(value)
                self._set_model_modified(True)
            else:
                raise ValueNotPossibleError(message = 'Cannot set the value {}. Only the values between {} and {} are possible'.format(str(value), str(self.__min), str(self.__max)))
        {%- else %}
            self.__value = value
            self.__valueNode.text = value
            self._set_model_modified(True)
        {%- endif %}

        #Get the type of parameter(if INTEGER, BOOLEAN, STRING, FUNCTION, FLOAT or ENUMERATION)
        def get_type(self):
            return self.__type
    
        def is_default_value_set(self):
            return self.__isDefaultValueSet
    
        def get_default_value(self):
            return self.__defaultValue
    
{% if parameter.get_type() == ParameterTypes.INTEGER or parameter.get_type() == ParameterTypes.FLOAT %}
        def is_min_value_set(self):
            return self.__isMinValueSet
    
        def get_min_value(self):
            return self.__min
    
        def is_max_value_set(self):
            return self.__isMaxValueSet
    
        def get_max_value(self):
            return self.__max
{% elif parameter.get_type() == ParameterTypes.ENUMERATION %}
        def get_enum_literals(self):
            return self.__enumLiterals
{% endif %}
{%- endmacro %}

{%- macro createReferenceClass(reference, ReferenceTypes) %}
    # Reference configuration node for {{ reference.get_name() }}
    class {{ reference.get_class_name() }}(AutosarNode):
        def __init__(self, parent, node):
            """
            Constructor for {{ reference.get_name() }} node.

            @param parent: The parent node under which the autosar node needs to be created.
            @param node: The xml node for which the autosar node needs to be created.
            """
            super().__init__(parent, node, '{{ reference.get_name() }}', '{{ reference.get_path() }}')
            self.__valueNode = node.find('{*}VALUE-REF')
            self.__value = self.__valueNode.text if self.__valueNode is not None else None
            self.__type = {{ reference.get_type() }}
{%- if reference.get_type() == ReferenceTypes.SIMPLE_REFERENCE %}
            self.__destinationRef = '{{ reference.get_destination() }}'
{% elif reference.get_type() == ReferenceTypes.CHOICE_REFERENCE %}
            self.__destinationRefs = {{ reference.get_destinations() }}
{% elif reference.get_type() == ReferenceTypes.FOREIGN_REFERENCE %}
            self.__destinationType = '{{ reference.get_destination_type() }}'
{%- endif %}

        #Get the reference value
        def get_value(self):
            return self.__value

        #set the reference value
        def set_value(self, value):
            self.__value = value
            self.__valueNode.text = value
            self._set_model_modified(True)

        #Get the type of reference(if SIMPLE_REFERENCE, CHOICE_REFERENCE or FOREIGN_REFERENCE)
        def get_type(self):
            return self.__type
    
{% if reference.get_type() == ReferenceTypes.SIMPLE_REFERENCE %}
        #Gets the value of DESTINATION-REF from the definition file.
        def get_destination_ref(self):
            return self.__destinationRef
{% elif reference.get_type() == ReferenceTypes.CHOICE_REFERENCE %}
        #Gets the value of DESTINATION-REF from the definition file for CHOICE_REFERENCE.
        def get_destination_refs(self):
            return self.__destinationRefs
{% elif reference.get_type() == ReferenceTypes.FOREIGN_REFERENCE %}
        #Gets the value of DESTINATION-TYPE from the definition file for FOREIGN_REFERENCE.
        def get_destination_type(self):
            return self.__destinationType
{%- endif %}
{%- endmacro %}


{%- macro createContainer(container, ParameterTypes, ReferenceTypes) -%}
{{ createContainerClass(container) }}
{# Internal comment :  parameters and references will be generated as inner classes to the container class. #}
{%- for parameter in container.get_parameters() %}
{{ createParameterClass(parameter, ParameterTypes) }}
{% endfor %}
{%- for reference in container.get_references() %}
{{ createReferenceClass(reference, ReferenceTypes) }}
{% endfor %}
{%- for subContainer in container.get_sub_containers() %}
{{ createContainer(subContainer, ParameterTypes, ReferenceTypes) }}
{% endfor %}
{%- endmacro %}