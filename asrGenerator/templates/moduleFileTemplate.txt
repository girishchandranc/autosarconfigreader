{% import 'helper.txt' as helper -%}
"""
The python file contains the different classes for accessing the containers and parameters of the '{{ module.get_name() }}' module.
This file is generated for the module '{{ module.get_name() }}' on {{ time }}.
"""

from lxml import etree
from enum import Enum

# Enums for possible parameter and reference types
ParameterTypes = Enum('ParameterTypes', 'INTEGER FLOAT BOOLEAN STRING FUNCTION ENUMERATION')
ReferenceTypes = Enum('ReferenceTypes', 'SIMPLE_REFERENCE CHOICE_REFERENCE FOREIGN_REFERENCE')

# dict supposed to be used internally by the module to store the path and its corresponding autosar node
pathsToNodeDict = {}
# dict supposed to be used internally by the module to store the instances of autosar node for the definition path
definitionPathToNodesDict = {}

def read_and_build_module_configuration(file):
    """
    Reads the module configuration and build the {{ module.get_name() }} structure.

    @param file: The configuration arxml file.
    @return:  The built {{ module.get_name() }} structure. May return None if the given 
              file do not contain the module configuration for
              {{ module.get_name() }}.
    """
    #Clearing the cache if any before building the module
    pathsToNodeDict.clear()
    definitionPathToNodesDict.clear()

    rootAutosarNode = etree.parse(file)
    moduleConfNode = None
    #{*} is used to consider the wildcard namespace.
    for module in rootAutosarNode.findall('//{*}ECUC-MODULE-CONFIGURATION-VALUES'):
        definitionRef = module.find('{*}DEFINITION-REF').text
        if definitionRef is not None and definitionRef.split('/').pop() == '{{ module.get_name() }}':
            moduleConfNode = module
            break

    if moduleConfNode is not None:
        return {{ module.get_name() }}(file, rootAutosarNode, moduleConfNode)
    else:
        return None

def get_node(path):
    """
    Returns the autosar node for the corresponding path.

    @param path: The fully qualified autosar path for eg: /Autosar/Module/Container1.
    @return:  The node corresponding to the path or None if the node for path is not available.
    """
    if path in pathsToNodeDict:
        return pathsToNodeDict[path]
    else:
        return None

def get_nodes_for_definition_path(path):
    """
    Returns the autosar nodes for the corresponding definition path.

    @param path: The fully qualified autosar path starting from the module name 
                 and avoiding the Ar-package(eg: /Module/Container1).
    @return:  The nodes corresponding to the path or None if the node for path is not available.
    """
    if path in definitionPathToNodesDict:
        return definitionPathToNodesDict[path]
    else:
        return None

# Base class for all autosar nodes
class AutosarNode:
    def __init__(self, parent, node, definitionName, definitionPath):
        """
        Constructor for any Autosar node.

        @param parent: The parent node under which the autosar node needs to be created.
        @param node: The xml node for which the autosar node needs to be created.
        @param definitionName: The definition short name of the node.
        @param definitionPath: The fully qualified path of the definition node.
        """
        self.__parent = parent
        self.__node = node
        self.__name = None
        shortNameNode = node.find('{*}SHORT-NAME')
        if shortNameNode is not None:
            self.__name = shortNameNode.text
        else:
            self.__name = definitionName
        self.__definitionName = definitionName
        names = []
        names.append(self.__name)
        self.__compute_path(node.getparent(), names)
        self.__path = self.__build_path(reversed(names))
        pathsToNodeDict[self.__path] = self

        if definitionPath == self.__get_definition_path_of_node(node):
            if definitionPath not in definitionPathToNodesDict:
                nodes = []
                definitionPathToNodesDict[definitionPath] = nodes

            definitionPathToNodesDict[definitionPath].append(self)

    def __compute_path(self, node, names):
        #get all path until the AUTOSAR root node
        if node.tag.endswith('AUTOSAR'):
            return names
        else:
            shortNameNode = node.find('{*}SHORT-NAME')
            if shortNameNode is not None:
                names.append(shortNameNode.text)

            return self.__compute_path(node.getparent(), names)
    
    def __build_path(self, names):
        returnValue = ''
        for name in names:
            returnValue = returnValue + '/' + name
        return returnValue
    
    def __get_definition_path_of_node(self, node):
        definitionPath = None
        definitionRef = node.find('{*}DEFINITION-REF').text
        if definitionRef is not None:
            defNameList = definitionRef.split('/')
            resulantDefNames = []
            moduleFound = False
            for name in defNameList:
                if name == '{{ module.get_name() }}':
                    moduleFound = True
                if moduleFound:
                    resulantDefNames.append(name)
            definitionPath = self.__build_path(resulantDefNames)
        return definitionPath

    def get_parent(self):
        return self.__parent

    def get_short_name(self):
        return self.__name

    def get_definition_name(self):
        return self.__definitionName
    
    def get_node(self):
        return self.__node
    
    def get_path(self):
        return self.__path

    def _set_model_modified(self, value):
        """ 
        To be set when a model is modified. It calls 
        the parent until the module node is found. 
        Please check the module sub class for more info.
        """
        self.__parent._set_model_modified(value)

# Module configuration node(root node for the respective module)
class {{ module.get_name() }}(AutosarNode):
    def __init__(self, file, rootNode, node):
        """
        Constructor for {{ module.get_name() }} node.

        @param file: The input file used to create the module.
        @param rootNode: The root node corresponding to the file.
        @param node: The xml node for which the autosar node needs to be created.
        """
        super().__init__(None, node, '{{ module.get_name() }}', '{{ module.get_path() }}')
        self.__rootNode = rootNode
        self.__file = file
        self.__isModelModified = False
        {% for container in module.get_containers() -%}
            {%- if container.is_multi_instance_container() %}
        self.__{{ container.get_name() }}s = []
            {%- else %}
        self.__{{ container.get_name() }} = None
            {%- endif %}  
        {%- endfor %}


        for container in node.findall('{*}CONTAINERS/{*}ECUC-CONTAINER-VALUE'):
            definitionRef = container.find('{*}DEFINITION-REF').text
            if definitionRef is not None:
                definitionName = definitionRef.split('/').pop()
            {%- for container in module.get_containers() %}
                {%- if loop.first %}
                if definitionName == '{{ container.get_name() }}':
                {%- else %}
                elif definitionName == '{{ container.get_name() }}':
                {%- endif %}
                {%- if container.is_multi_instance_container() %}
                    self.__{{ container.get_name() }}s.append({{ container.get_name() }}(self, container))
                {%- else %}
                    self.__{{ container.get_name() }} = {{ container.get_name() }}(self, container)
                {%- endif %}  
            {%- endfor %}

    def _set_model_modified(self, value):
        self.__isModelModified = True
    
    def is_model_modified(self):
        return self.__isModelModified

{% for container in module.get_containers() %}
    #Returns the configuration container {{ container.get_name() }}
    {%- if container.is_multi_instance_container() %}
    def get_{{ container.get_name() }}s(self):
        return self.__{{ container.get_name() }}s
    {%- else %}
    def get_{{ container.get_name() }}(self):
        return self.__{{ container.get_name() }}
    {%- endif %}  
{% endfor %}

    def save(self, file = None):
        """
        Saves the configuration:
            - To the file passed as argument
            - Overwrite the existing file if no argument is provided
        
        Raises an exception if save() is called without a module

        @param file: The file location where the configuration needs to be saved.
        """
        if self.__isModelModified is False:
            return 'The model is not changed. Ignoring the save request!'
        elif file is not None:
            self.__rootNode.write(file, pretty_print=True, xml_declaration=True,   encoding="utf-8")
        else:
            self.__rootNode.write(self.__file, pretty_print=True, xml_declaration=True,   encoding="utf-8")
        return 'The model saved!'

{% for container in module.get_containers() %}
{{ helper.createContainer(container, ParameterTypes, ReferenceTypes) }}
{% endfor %}

# Exception classes
class ValueNotPossibleError(Exception):
    """Exception raised when the provided value is not possible to set for the parameter"""
    def __init__(self, message):
        super().__init__(message)

class FileSaveError(Exception):
    """Exception raised when the file is unable to save"""
    def __init__(self, message):
        super().__init__(message)